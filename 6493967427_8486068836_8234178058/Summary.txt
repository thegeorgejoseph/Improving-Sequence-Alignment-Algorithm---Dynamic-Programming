CSCI 570 : Final Project
========================

Contributers:
-------------

Name: Amal Jose
USC ID: 6493967427
Contribution: Plotting graphs of CPU Time and Memory Usage, Preparing Documentation

Name: George Joseph
USC ID: 8486068836
Contribution: Coding and testing Basic version of the algorithm, String generator, Preparing Documentation

Name: Srinivasan KS
USC ID: 8234178058
Contribution: Coding and testing Efficient version of the algorithm, Preparing Documentation

Analysis of results:
--------------------

The time and the memory consumption of both the Basic and the Efficient Algorithms are timed using the script in utils.py.
The Algorithms provide a similar complexity in terms of timed execution but show considerable variations in the utilization of memory spaces.
This can be elucidated with an sample test input mentioned below which ran on both the algorithms.

String 1 
---------                  
ACTG
1
6
4
10
56
75
202
359

String 2
-----------
TACG
2
2
14
22
17
66
90

The results of these strings on the Basic and Efficient versions of the Algorithm are as follows

Basic Algorithm
----------------

ACACTACACTGACACTACACTGTACACTGTGGGTAC_ACTGTGGTAC_ACT TACACTGTGGGTAC_ACTGTGGTACACTGTGGGTACACTGTGGACTGTGG
____T__ACT___ACTACG__GT__AC_____GTACTAC_____TACTAC_ T__AC_____GTACTACTACGGT__AC___GGG__CG__GT__AC_G_GG
17484               (Cost)
2.1070666313171387  (Time)
15092.1015625       (Memory)

Efficient Algorithm
-------------------

ACACTACACTGACACTACACTGTACACTGTGGGTAC_ACTGTGGTAC_ACT GTACACTGTGGGTACACTGTGGTACACTGTGGGTACACTGTGGACTGTGG
____TAC__T_AC__TACG__GTAC___GT____ACTACT_____ACTAC_ __AC___G_G__TAC___G_GG__C___G_G__TAC___G_G_______G
17484               (Cost)     
3.9204325675964355  (Time)
18.416015625        (Memory)

It is evident from the executions of both the versions that the runtime of both the algorithms is somewhat similar but the space complexity of the algorithms is completely different.
For the above testcase, the memory consumption is reduced in the Efficient Algorithm by 840 times the memory usage in the Basic Algorithm. 


Insights and Observations:
--------------------------

Basic Algorithm

The basic or naive implementation of the Sequence Alignment Problem involves the usage of Dynamic Programming. The basic approach involves usage of a matrix of dimension m * n where m and n are the lengths of the strings s1 and s2 respectively.  The runtime complexity of the algorithm is O(mn). The recurrance equation is framed with respective to the paramters like delta and penalty for the different mismatches.

Time Complexity - O(mn)
Space Complexity - O(mn)

Efficient Algorithm

The efficient algorithm makes use of Divide and Conquer Strategy for Sequence Alignment Problem.

We find the minimum cost for the operations to solve the alignment problem. We then make use of the cost to determine the split points for the strings to divide them. In this approach we become aware of the split points and divide the strings appropriately to get 2 subproblems which are repeatedly broken down to smaller subproblems and finally we make use of our basic algorithm to perform the computation.

Time Complexity - O(mn)
Space Complexity - O(2m)

This is one of the most efficient solutions with respective to the space complexity.

Testing and Execution Strategy
------------------------------

Every graph is plotted by taking 20 test cases that are randomly generated at each instance to ensure correctness of the execution of the algorithm. 
This is generated using plotter.py util.
Each instance of the string that is being tested is generated by the utility stringGenerator.py. 